/**
 * @author Alan Perez-Rathke 
 *
 * @date April 14, 2011
 *
 * Department of Computer Science
 * University of Illinois at Chicago 
 */

#ifndef TPkRawBitSetHandle_h
#define TPkRawBitSetHandle_h

#include "PkBuild.h"
#include "PkAssert.h"
#include "PkTypes.h"
#include "PkRawBitSetCompileTimeProperties.h"
#include "PkFindLowestBitPositionUtil.h"
#include <algorithm>

// Macro to declare byte to bit count mapping
// Automatically generated by GPTableGen.exe v.1.0
//
#define Pk_INIT_NUM_BITS_IN_BYTE_TABLE \
	{ \
		0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, \
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, \
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, \
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, \
		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, \
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, \
		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, \
		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8  \
	}

// Run time properties policy for use in TPkRawBitSetHandle
class PkBitSetWrapperRunTimeProperties
{
public:

	// @return The number of bits in the bit set
	inline PkBitSet::size_type size() const { return m_parent_bit_set.size(); }

	// @return The number of blocks necessary to represent a bit set
	inline PkBitSet::size_type num_blocks() const { return m_parent_bit_set.num_blocks(); }

	// @return The number of bytes necessary to represent a bit set
	inline PkBitSet::size_type num_bytes() const { return num_blocks() * size(); }

	// Constructor constructor
	explicit PkBitSetWrapperRunTimeProperties(
		  const PkBitSet& parent_bit_set
		) : m_parent_bit_set( parent_bit_set )
	{}

private:

	// A reference to parent bit set array containing this bit set
	const PkBitSet& m_parent_bit_set;
};

// A class that wraps around a raw bit buffer and allows bit manipulation
template< typename tPkRawBitSetRuntimeProperties >
class TPkRawBitSetHandle : public PkRawBitSetCompileTimeProperties
{
public:

	// Constructor to initialize bit buffer and runtime properties
	TPkRawBitSetHandle( 
		  buffer_type bits
		, const tPkRawBitSetRuntimeProperties& runtime_properties
		) : m_bits( bits )
		  , m_runtime_properties( runtime_properties )
	{}

	// @return The number of bits in the bit set
	inline size_type size() const { return m_runtime_properties.size(); }

	// @return The number of blocks necessary to represent a bit set
	inline size_type num_blocks() const { return m_runtime_properties.num_blocks(); }

	// @return The number of bytes necessary to represent a bit set
	inline size_type num_bytes() const { return m_runtime_properties.num_bytes(); }

	// We need to expose underlying buffer!
	inline const buffer_type get_buffer() const { return m_bits; };

	// bitset operations - based on boost::dynamic_bitset
	
	template< typename tBitSet >
    TPkRawBitSetHandle& operator&=( const tBitSet& rhs )
	{
		assert(size() == rhs.size());
		for (size_type i = 0; i < num_blocks(); ++i)
		{
			m_bits[i] &= rhs.get_buffer()[i];
		}
		return *this;
	}

	template< typename tBitSet >
    TPkRawBitSetHandle& operator|=( const tBitSet& rhs )
	{
		assert(size() == rhs.size());
		for (size_type i = 0; i < num_blocks(); ++i)
		{
			m_bits[i] |= rhs.get_buffer()[i];
		}
		return *this;
	}

	template< typename tBitSet >
    TPkRawBitSetHandle& operator^=( const tBitSet& rhs )
	{
		assert(size() == rhs.size());
		for (size_type i = 0; i < num_blocks(); ++i)
		{
			m_bits[i] ^= rhs.get_buffer()[i];
		}
		return *this;
	}

	template< typename tBitSet >
	TPkRawBitSetHandle operator-=(const tBitSet& rhs)
	{
		assert(size() == rhs.size());
		for (size_type i = 0; i < num_blocks(); ++i)
			m_bits[i] &= ~rhs.get_buffer()[i];
		return *this;
	}

	TPkRawBitSetHandle& operator<<=( const size_type n );
	TPkRawBitSetHandle& operator>>=(size_type n);
	PkBitSet operator<<(size_type n) const;
	PkBitSet operator>>(size_type n) const;

	// basic bit operations - based on boost::dynamic_bitset

	TPkRawBitSetHandle& set(size_type n, bool val = true);
	TPkRawBitSetHandle& set();
	TPkRawBitSetHandle& reset(size_type n);
	TPkRawBitSetHandle& reset();
	TPkRawBitSetHandle& flip(size_type n);
	TPkRawBitSetHandle& flip();
	bool test(size_type n) const;
	bool any() const;
	bool none() const;
	PkBitSet operator~() const;
	size_type count() const;

	template< typename tBitSet >
	bool is_subset_of( const tBitSet& a ) const
	{
		PkAssert( size() == a.size() );
		PkAssert( num_blocks() == a.num_blocks() );
		PkAssert( sizeof( block_type ) == sizeof( typename tBitSet::block_type ) );
		for (size_type i = 0; i < num_blocks(); ++i)
		{
			if (m_bits[i] & ~a.get_buffer()[i])
			{
				return false;
			}
		}
		return true;
	}

	template< typename tBitSet >
    bool is_proper_subset_of( const tBitSet& a ) const
	{
		PkAssert( size() == a.size() );
		PkAssert( num_blocks() == a.num_blocks() );
		PkAssert( sizeof( block_type ) == sizeof( typename tBitSet::block_type ) );

		bool proper = false;
		
		for (size_type i = 0; i < num_blocks(); ++i) 
		{
			const block_type& bt =   m_bits[i];
			const block_type& ba = a.get_buffer()[i];

			if (bt & ~ba)
				return false; // not a subset at all
			if (ba & ~bt)
				proper = true;
		}

		return proper;
	}

	template< typename tBitSet >
    bool intersects( const tBitSet & b ) const
	{
		size_type common_blocks = ( num_blocks() < b.num_blocks() ) ? num_blocks() : b.num_blocks();
		for(size_type i = 0; i < common_blocks; ++i)
		{
			if ( m_bits[i] & b.get_buffer()[i] )
			{
				return true;
			}
		}
		return false;
	}

    // lookup / bit iteration routines - based on boost::dynamic_bitset

    size_type find_first() const;
    size_type find_next(size_type pos) const;

	// Converts this handle into a stand-alone PkBitSet
	// @return the converted parameter bit set
	PkBitSet& to_PkBitSet( PkBitSet& out_bit_set ) const;

	// comparison
    
	template < typename tPkRawBitSetRuntimeProperties, typename tBitSet >
    friend bool operator==(const TPkRawBitSetHandle<tPkRawBitSetRuntimeProperties>& a, const tBitSet& b);

private:

	bool m_unchecked_test(size_type pos) const;
	size_type m_do_find_from(size_type first_block) const;
	unsigned long m_lowest_bit_position( block_type b ) const;

	// Utilities - based on boost::dynamic_bitset
	block_type& m_highest_block();
    const block_type& m_highest_block() const;
	void m_zero_unused_bits();
	inline block_width_type count_extra_bits() const { return bit_index(size()); }
    inline static size_type block_index(size_type pos) { return pos / bits_per_block; }
    inline static block_width_type bit_index(size_type pos) { return static_cast<block_width_type>(pos % bits_per_block); }
    inline static block_type bit_mask(size_type pos) { return block_type(1) << bit_index(pos); }

	// The raw bit buffer for bit manipulation
	buffer_type m_bits;

	// Properties to determine bit, block, and byte counts
	const tPkRawBitSetRuntimeProperties m_runtime_properties;
};

//-----------------------------------------------------------------------------
// Utilities to determine bit set size

// Generic function to get number of bytes in a bitset
template <typename tBitSet >
inline PkRawBitSetCompileTimeProperties::size_type PkGetBitSetNumBytes( const tBitSet& bit_set )
{
	PkAssert( false && "No template match for bit set type!" );
	return 0;
}

// Specialized template to determine number of bytes in a dynamic bit set
template <>
inline PkRawBitSetCompileTimeProperties::size_type PkGetBitSetNumBytes( const PkBitSet& bit_set )
{
	return bit_set.get_buffer().size() * sizeof( PkBitSet::block_type );
}

// Specialized template to determine number of bytes in a raw bit set handle
template< typename tPkRawBitSetRuntimeProperties >
inline PkRawBitSetCompileTimeProperties::size_type PkGetBitSetNumBytes(
	  const TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& bit_set 
	)
{
	return bit_set.num_bytes();
}

// Return minimum number of bytes between the two bit set
template < typename tBitSetA, typename tBitSetB >
inline PkRawBitSetCompileTimeProperties::size_type PkGetBitSetMinNumBytes(
	  const tBitSetA& bit_set_a
	, const tBitSetB& bit_set_b
	)
{
	return std::min<>( PkGetBitSetNumBytes( bit_set_a ), PkGetBitSetNumBytes( bit_set_b ) );
}

//-----------------------------------------------------------------------------
// bitset operations

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& 
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::operator<<=( const size_type n )
{
	// If shift amount is greater than bit set size, then just reset everything to zero
	if ( n >= size() )
	{
		return reset();
	}

	// else
	if ( n > 0 )
	{
		const size_type last     = num_blocks() - 1;   // num_blocks() is >= 1
		const size_type div      = n / bits_per_block; // div is <= last
		const block_width_type r = bit_index(n);
		block_type * const b     = &m_bits[0];

		if ( r != 0 ) 
		{
			block_width_type const rs = bits_per_block - r;

			for (size_type i = last-div; i>0; --i) 
			{
				b[i+div] = (b[i] << r) | (b[i-1] >> rs);
			}
			b[div] = b[0] << r;
		}
		else 
		{
			for (size_type i = last-div; i>0; --i)
			{
				b[i+div] = b[i];
			}
			b[div] = b[0];
		}

		// zero out div blocks at the less significant end
		std::fill_n(b, div, static_cast<block_type>(0));

		// zero out any 1 bit that flowed into the unused part
		m_zero_unused_bits(); // thanks to Lester Gong
	}

	return *this;
}

// Based on boost::dynamic_bitset
template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& 
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::operator>>=( size_type n )
{
	if ( n >= size() )
	{
		return reset();
	}

	// else
	if ( n>0 )
	{
		const size_type last     = num_blocks() - 1;     // num_blocks() is >= 1
		const size_type div      = n / bits_per_block;   // div is <= last
		const block_width_type r = bit_index(n);
		block_type * const b     = &m_bits[0];

		if (r != 0)
		{
			block_width_type const ls = bits_per_block - r;

			for (size_type i = div; i < last; ++i) 
			{
				b[i-div] = (b[i] >> r) | (b[i+1]  << ls);
			}
			// r bits go to zero
			b[last-div] = b[last] >> r;
		}
		else
		{
			for (size_type i = div; i <= last; ++i)
			{
				b[i-div] = b[i];
			}
			// note the '<=': the last iteration 'absorbs'
			// b[last-div] = b[last] >> 0;
		}

		// div blocks are zero filled at the most significant end
		std::fill_n(b + (num_blocks()-div), div, static_cast<block_type>(0));
	}

	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
PkBitSet TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::operator<<(size_type n) const
{
	PkBitSet r;
	return to_PkBitSet( r ) <<= n;
}

template< typename tPkRawBitSetRuntimeProperties >
PkBitSet TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::operator>>(size_type n) const
{
	PkBitSet r;
	return to_PkBitSet( r ) >>= n;
}

//-----------------------------------------------------------------------------
// global bitset operators

template< typename tPkRawBitSetRuntimeProperties, typename tBitSet >
PkBitSet operator&( const TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& x, const tBitSet& y)
{
	PkAssert( sizeof(TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type) == sizeof(PkBitSet::block_type) );
	PkBitSet b;
	x.to_PkBitSet( b );
	TPkRawBitSetHandle< PkBitSetWrapperRunTimeProperties > b_wrapped(
		  (PkRawBitSetCompileTimeProperties::buffer_type)(&b.get_buffer()[0])
		, PkBitSetWrapperRunTimeProperties( b )
		);
    b_wrapped &= y;
	return b;
}

template< typename tPkRawBitSetRuntimeProperties, typename tBitSet >
PkBitSet operator|( const TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& x, const tBitSet& y)
{
	PkAssert( sizeof(TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type) == sizeof(PkBitSet::block_type) );
	PkBitSet b;
	x.to_PkBitSet( b );
	TPkRawBitSetHandle< PkBitSetWrapperRunTimeProperties > b_wrapped(
		  (PkRawBitSetCompileTimeProperties::buffer_type)(&b.get_buffer()[0])
		, PkBitSetWrapperRunTimeProperties( b )
		);
    b_wrapped |= y;
	return b;
}

template< typename tPkRawBitSetRuntimeProperties, typename tBitSet >
PkBitSet operator^( const TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& x, const tBitSet& y)
{
	PkAssert( sizeof(TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type) == sizeof(PkBitSet::block_type) );
	PkBitSet b;
	x.to_PkBitSet( b );
	TPkRawBitSetHandle< PkBitSetWrapperRunTimeProperties > b_wrapped(
		  (PkRawBitSetCompileTimeProperties::buffer_type)(&b.get_buffer()[0])
		, PkBitSetWrapperRunTimeProperties( b )
		);
    b_wrapped ^= y;
	return b;
}

template< typename tPkRawBitSetRuntimeProperties, typename tBitSet >
PkBitSet operator-( const TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >& x, const tBitSet& y)
{
	PkAssert( sizeof(TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type) == sizeof(PkBitSet::block_type) );
	PkBitSet b;
	x.to_PkBitSet( b );
	TPkRawBitSetHandle< PkBitSetWrapperRunTimeProperties > b_wrapped(
		  (PkRawBitSetCompileTimeProperties::buffer_type)(&b.get_buffer()[0])
		, PkBitSetWrapperRunTimeProperties( b )
		);
    b_wrapped -= y;
	return b;
}

//-----------------------------------------------------------------------------
// basic bit operations

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::set(size_type pos, bool val)
{
	PkAssert( pos < size() );

	if (val)
	{
		m_bits[block_index(pos)] |= bit_mask(pos);
	}
	else
	{
		reset(pos);
	}

	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::set()
{
	memset( &m_bits[0], ~block_type(0), num_bytes() );
	m_zero_unused_bits();
	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::reset(size_type pos)
{
	PkAssert( pos < size() );
	m_bits[block_index(pos)] &= ~bit_mask(pos);
	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::reset()
{
	memset( &m_bits[0], block_type(0), num_bytes() );
	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::flip(size_type pos)
{
	PkAssert( pos < size() );
	m_bits[block_index(pos)] ^= bit_mask(pos);
	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >&
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::flip()
{
	for (size_type i = 0; i < num_blocks(); ++i)
	{
		m_bits[i] = ~m_bits[i];
	}
	m_zero_unused_bits();
	return *this;
}

template< typename tPkRawBitSetRuntimeProperties >
bool TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_unchecked_test(size_type pos) const
{
	return (m_bits[block_index(pos)] & bit_mask(pos)) != 0;
}

template< typename tPkRawBitSetRuntimeProperties >
bool TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::test(size_type pos) const
{
    PkAssert( pos < size() );
    return m_unchecked_test(pos);
}

template< typename tPkRawBitSetRuntimeProperties >
bool TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::any() const
{
	for (size_type i = 0; i < num_blocks(); ++i)
	{
		if (m_bits[i])
		{
			return true;
		}
	}
	return false;
}

template< typename tPkRawBitSetRuntimeProperties >
inline bool TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::none() const
{
	return !any();
}

template< typename tPkRawBitSetRuntimeProperties >
PkBitSet TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::operator~() const
{
	PkBitSet b;
	return to_PkBitSet( b ).flip();
}

template< typename tPkRawBitSetRuntimeProperties >
typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::size_type
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::count() const
{
	// Assert we have no padding bits
	PkAssert( bits_per_block == ( CHAR_BIT * sizeof(block_type) ) );

	static const byte_type num_bits_in_byte_table[] = Pk_INIT_NUM_BITS_IN_BYTE_TABLE;

	const byte_type* byte_buffer = (byte_type*) m_bits;
	
	size_type num_positive_bits = 0;

	for ( int i=0; i<num_bytes(); ++i )
	{
		num_positive_bits += num_bits_in_byte_table[ byte_buffer[ i ] ];
	}

	return num_positive_bits;
}

// --------------------------------
// lookup

// look for the first bit "on", starting
// from the block with index first_block
//
template< typename tPkRawBitSetRuntimeProperties >
typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::size_type
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_do_find_from(size_type first_block) const
{
	size_type i = first_block;

	// skip null blocks
	while (i < num_blocks() && m_bits[i] == 0)
	{
		++i;
	}

	if ( i >= num_blocks() )
	{
		return npos; // not found
	}

	return i * bits_per_block + m_lowest_bit_position( m_bits[i] );
}

template< typename tPkRawBitSetRuntimeProperties >
unsigned long TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_lowest_bit_position( block_type b ) const
{
	PkAssert( sizeof( block_type ) == sizeof( unsigned long ) );
	unsigned long lowest_bit_position = 0;
	PkVerify( 0 != PkFindLowestBitPosition( &lowest_bit_position, b ) );
	return lowest_bit_position;
}

template< typename tPkRawBitSetRuntimeProperties >
typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::size_type
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::find_first() const
{
	return m_do_find_from(0);
}

template< typename tPkRawBitSetRuntimeProperties >
typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::size_type
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::find_next(size_type pos) const
{
	const size_type sz = size();
	if ( pos >= (sz-1) || sz == 0 )
	{
		return npos;
	}

	++pos;
	
	const size_type blk = block_index(pos);
	const block_width_type ind = bit_index(pos);

	// mask out bits before pos
	const block_type fore = m_bits[blk] & ( ~block_type(0) << ind );

	return fore
		? blk * bits_per_block + m_lowest_bit_position(fore)
		: m_do_find_from(blk + 1);
}

// Converts this handle into a stand-alone PkBitSet
template< typename tPkRawBitSetRuntimeProperties >
PkBitSet& TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::to_PkBitSet( PkBitSet& out_bit_set ) const
{
	out_bit_set.resize( size(), false );
	memcpy( 
		  (void*)&(out_bit_set.get_buffer()[0])
		, &m_bits[0] 
		, PkGetBitSetMinNumBytes( out_bit_set, *this )
		);
	return out_bit_set;
}

//-----------------------------------------------------------------------------
// comparison

template < typename tPkRawBitSetRuntimeProperties, typename tBitSet >
bool operator==(const TPkRawBitSetHandle<tPkRawBitSetRuntimeProperties>& a, const tBitSet& b)
{
	return (a.size() == b.size())
		&& (0 == memcmp(
				  &(a.get_buffer()[0])
				, &(b.get_buffer()[0])
				, PkGetBitSetMinNumBytes( a, b )
				) );
}

template < typename tPkRawBitSetRuntimeProperties, typename tBitSet >
inline bool operator!=(const TPkRawBitSetHandle<tPkRawBitSetRuntimeProperties>& a, const tBitSet& b)
{
	return !(a == b);
}

// Based on boost::dynamic_bitset
// gives a reference to the highest block
//
template< typename tPkRawBitSetRuntimeProperties >
inline typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type& 
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_highest_block()
{
	return const_cast<block_type &>
		(static_cast<const TPkRawBitSetHandle *>(this)->m_highest_block());
}

// Based on boost::dynamic_bitset
// gives a const-reference to the highest block
//
template< typename tPkRawBitSetRuntimeProperties >
inline const typename TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::block_type& 
TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_highest_block() const
{
    assert(size() > 0 && num_blocks() > 0);
    return m_bits[ num_blocks()-1 ];
}

// Based on boost::dynamic_bitset
// If size() is not a multiple of bits_per_block
// then not all the bits in the last block are used.
// This function resets the unused bits (convenient
// for the implementation of many member functions)
//
template< typename tPkRawBitSetRuntimeProperties >
inline void TPkRawBitSetHandle< tPkRawBitSetRuntimeProperties >::m_zero_unused_bits()
{
	assert (num_blocks() == calc_num_blocks(m_num_bits));

	// if != 0 this is the number of bits used in the last block
	const block_width_type extra_bits = count_extra_bits();

	if (extra_bits != 0)
	{
		m_highest_block() &= ~(~static_cast<block_type>(0) << extra_bits);
	}
}

#endif // TPkRawBitSetHandle_h
